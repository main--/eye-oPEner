extern crate pe;
extern crate libc;
extern crate widestring;
#[macro_use]
extern crate lazy_static;
extern crate rand;

use std::fs::File;
use std::io::Read;
use std::{ptr, mem, io, iter, slice, fmt};
use std::ffi::CStr;
use std::sync::Mutex;
use std::collections::HashMap;

use pe::{Pe, PeOptionalHeader, AsOsStr, RVA, ExportAddress};
use pe::types::{ImportDirectory, ImageThunkData, RelocationType, PeOptionalHeader64};
use pe::{URP, URPConvert};
use libc::{mmap, MAP_PRIVATE, MAP_ANONYMOUS, MAP_FIXED, mprotect, c_void, c_char, PROT_EXEC, PROT_WRITE, PROT_READ};
use widestring::WideCStr;
use rand::Rng;

macro_rules! impl_winapi {
    ( $( fn $name:ident ( $($pn:ident : $t:ty),* ) -> $ret:ty $body:block )+ ) => (
        $(
            #[allow(non_snake_case)]
            unsafe extern "win64" fn $name ( $($pn : $t),* ) -> $ret {
                print!("{}(", stringify!($name));
                $( print!("{:?}, ", $pn); )*;
                println!(")");
                
                $body
            }
        )+

        lazy_static! {
            static ref WINAPI: ::std::collections::HashMap<&'static str, u64> = {
                let mut map = ::std::collections::HashMap::new();
                $( map.insert(stringify!($name), $name as u64); )+;
                map
            };
        }
    )
}


struct Lpcstr(*const c_char);

impl Lpcstr {
    fn load(&self) -> Option<&CStr> {
        if self.0.is_null() {
            None
        } else {
            Some(unsafe { CStr::from_ptr(self.0) })
        }
    }
}

impl fmt::Debug for Lpcstr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if let Some(cs) = self.load() {
            fmt::Debug::fmt(cs, f)
        } else {
            f.write_str("<null>")
        }
    }
}

struct Lpcwstr(*const u16);

impl Lpcwstr {
    fn load(&self) -> Option<&WideCStr> {
        if self.0.is_null() {
            None
        } else {
            Some(unsafe { WideCStr::from_ptr_str(self.0) })
        }
    }
}

impl fmt::Debug for Lpcwstr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if let Some(cs) = self.load() {
            write!(f, "\"{}\"", cs.to_string_lossy())
        } else {
            f.write_str("<null>")
        }
    }
}

#[repr(C, packed)]
struct WinSystemInfo {
    arch: u16,
    resv: u16,
    page_size: u32,
    min_addr: *mut c_void,
    max_addr: *mut c_void,
    active_processor_mask: usize,
    number_of_processors: u32,
    processor_type: u32,
    allocation_granularity: u32,
    processor_level: u16,
    processor_revision: u16,
}

lazy_static! {
    static ref FLS: Mutex<Vec<u64>> = Mutex::new(Vec::new());
}

impl_winapi! {
    fn malloc(size: usize) -> *mut c_void {
        libc::malloc(size)
    }

    fn free(ptr: *mut c_void) -> () {
        libc::free(ptr);
    }
    
    fn CreateMutexA(attr: *mut c_void, initial_owner: bool, name: Lpcstr) -> usize {
        1
    }
    
    fn CreateEventA(attr: *mut c_void, manual: bool, initial: bool, name: Lpcstr) -> usize {
        1
    }
    
    fn WaitForSingleObject(handle: usize, millis: u32) -> u32 {
        0
    }
    
    fn RegOpenKeyExA(key: u64, subkey: Lpcstr, options: u32, sam_desired: usize, result: *mut u64) -> u32 {
        *result = 0xdeadbeefdeadbeef;
        0
    }
    
    fn RegQueryValueExA(key: u64, value_name: Lpcstr, resv: *mut u32, typ: *mut u32, data: *mut u8, data_len: *mut u32) -> u32 {
        if !data.is_null() {
            let data = slice::from_raw_parts_mut(data, *data_len as usize);
            data[0] = b'l';
            data[1] = b'u';
            data[2] = b'l';
            data[3] = 0;
        }
        *data_len = 4;
        0
    }

    fn RegCloseKey(key: u64) -> u32 {
        0
    }
    
    fn ResetEvent(handle: usize) -> bool {
        true
    }
    
    fn ReleaseMutex(handle: usize) -> bool {
        true
    }
    
    fn GetCurrentThreadId() -> u32 {
        1337
    }
    
    fn GetCurrentProcessId() -> u32 {
        42
    }

    fn InitializeCriticalSectionEx(ptr: *mut c_void, spin_count: u32, flags: u32) -> bool {
        true
    }

    fn InitializeCriticalSectionAndSpinCount(ptr: *mut c_void, spin_count: u32) -> bool {
        true
    }

    fn EnterCriticalSection(ptr: *mut c_void) -> () {}
    fn LeaveCriticalSection(ptr: *mut c_void) -> () {}

    fn HeapAlloc(heap: usize, flags: u32, bytes: usize) -> *mut c_void {
        libc::malloc(bytes)
    }

    fn HeapSize(heap: usize, flags: u32, mem: *mut c_void) -> usize {
        1usize.wrapping_neg()
    }

    fn FlsAlloc(ptr: *mut c_void) -> u32 {
        let mut fls = FLS.lock().unwrap();
        fls.push(0);
        fls.len() as u32 - 1
    }

    fn FlsSetValue(index: u32, data: u64) -> bool {
        let mut fls = FLS.lock().unwrap();
        fls[index as usize] = data;
        true
    }

    fn FlsGetValue(index: u32) -> u64 {
        FLS.lock().unwrap()[index as usize]
    }

    fn WideCharToMultiByte(code_page: u32,
                           flags: u32,
                           wide_str: Lpcwstr,
                           cch_wide_char: i32,
                           mb_str: *mut c_char,
                           cb_multi_byte: i32,
                           default_char: Lpcstr,
                           used_default_char: *mut bool) -> i32 {
        1 // LUL
    }

    fn GetStdHandle(kind: u32) -> usize {
        1
    }

    fn GetFileType(handle: usize) -> u32 {
        1
    }

    fn GetACP() -> u32 {
        65001
    }

    fn GetLastError() -> u32 {
        0
    }

    fn SetLastError(code: u32) -> () {
    }

    fn HeapFree(heap: usize, flags: u32, mem: *mut c_void) -> bool {
        libc::free(mem);
        true
    }

    fn GetModuleFileNameA(hmod: usize, filename: *mut u8, size: u32) -> u32 {
        *filename.offset(0) = b'x';
        *filename.offset(1) = 0;
        1
    }

    fn GetCommandLineA() -> *const c_char {
        let addr = libc::malloc(1) as *mut c_char;
        *addr = 0;
        addr
    }

    fn LoadLibraryA(name: Lpcstr) -> usize {
        2
    }

    fn GetModuleHandleW(name: Lpcwstr) -> usize {
        1
    }

    fn GetProcAddress(handle: usize, proc_name: Lpcstr) -> u64 {
        let name = proc_name.load().and_then(|x| x.to_str().ok()).unwrap();
        if let Some(&x) = WINAPI.get(name) {
            x
        } else if handle == 1 {
            0xadead1dea
        } else if let Some(&x) = COREFP.lock().unwrap().as_ref().unwrap().get(name) {
            x
        } else {
            unreachable!();
        }
    }
    
    fn GetSystemTimeAsFileTime(out: *mut u64) -> () {
        *out = 0;
    }

    fn QueryPerformanceCounter(out: *mut u64) -> usize {
        *out = 0;
        1
    }

    // allocaprobe

    fn GetEnvironmentStringsW() -> *mut u32 { // HACK
        let addr = libc::malloc(4) as *mut u32;
        *addr = 0;
        addr
    }

    fn FreeEnvironmentStringsW(ptr: *mut c_void) -> bool {
        libc::free(ptr);
        true
    }

    fn GetStartupInfoW(ptr: *mut c_void) -> () {
    }

    fn GetProcessHeap() -> usize {
        1
    }

    fn EncodePointer(ptr: *mut c_void) -> *mut c_void { ptr }
    fn DecodePointer(ptr: *mut c_void) -> *mut c_void { ptr }

    fn VirtualAlloc(addr: *mut c_void, size: usize, typ: u32, protect: u32) -> *mut c_void {
        libc::malloc(size)
    }

    fn GetSystemInfo(ptr: *mut WinSystemInfo) -> () {
        *ptr = mem::zeroed();
        (*ptr).arch = 9;
        (*ptr).page_size = 4096;
        (*ptr).allocation_granularity = 4096;
    }

    fn CryptAcquireContextA(phProv: *mut c_void,
                            pszContainer: Lpcstr,
                            pszProvider: Lpcstr,
                            dwProvType: u32,
                            dwFlags: u32) -> bool {
        true
    }

    fn CryptGenRandom(hProv: *mut c_void, dwLen: u32, pbBuffer: *mut u8) -> bool {
        rand::thread_rng().fill_bytes(slice::from_raw_parts_mut(pbBuffer, dwLen as usize));
        true
    }

    fn CryptReleaseContext(hProv: *mut c_void, flags: u32) -> bool {
        true
    }
}

type ExportTable = HashMap<String, u64>;

fn get_direct_exports(pe: &Pe, h: &PeOptionalHeader64) -> pe::Result<ExportTable> {
    let mut result = HashMap::new();
    let exports = pe.get_exports()?;

    for (&export, &offset) in exports.get_names()?.iter().zip(exports.get_ordinal_offsets()?) {
        let name = pe.ref_cstr_at(export).unwrap().as_os_str().to_string_lossy().into_owned();
        let addr = exports.get_export_addresses()?.get(offset as usize).ok_or(pe::Error::ExportNotFound)?;
        match exports.concretize_export_address(addr) {
            ExportAddress::Forwarder(_) => { }
            ExportAddress::Export(rva) => { result.insert(name, h.image_base + rva.get() as u64); }
        }
    }
    Ok(result)
}

fn alloc(addr: u64, size: u64) {
    let ret = unsafe { mmap(addr as *mut c_void,
                            size as usize,
                            PROT_EXEC | PROT_WRITE | PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
                            -1, 0) };
    if ret as isize == -1 { Err::<(), _>(io::Error::last_os_error()).unwrap(); }
}

fn map(pe: &Pe, h: &PeOptionalHeader64, raw: *const u8) {
    // headers
    alloc(h.image_base, h.size_of_headers as u64);
    unsafe { ptr::copy_nonoverlapping(raw, h.image_base as *mut u8, h.size_of_headers as usize) };
    
    for section in pe.get_sections() {
        let addr = h.image_base + section.virtual_address.get() as u64;
        alloc(addr, section.virtual_size as u64);
        
        let lame = pe.ref_slice_at(section.virtual_address, section.size_of_raw_data).unwrap().as_ptr();
        unsafe { ptr::copy_nonoverlapping(lame, addr as *mut u8, section.size_of_raw_data as usize) };
    }
}

fn link(pe: &Pe, h: &PeOptionalHeader64) {
    unsafe extern "win64" fn ordinal_import_stub() -> ! {
        println!("Attempted to call ordinal import. Aborting.");
        libc::abort();
    }
    
    unsafe extern "win64" fn unknown_import_stub() -> ! {
        println!("Attempted to call unknown import. Aborting.");
        libc::abort();
    }

    let idir = pe.get_directory::<ImportDirectory>().unwrap();
    let mut idir: *const ImportDirectory = pe.ref_at(idir.virtual_address).unwrap();
    loop {
        unsafe {
            if (*idir).name.get() == 0 { break; }
            println!("linking {:?}", pe.ref_cstr_at((*idir).name).unwrap().as_os_str());
            
            let thunk_in = if (*idir).original_first_thunk.get() != 0 {
                (*idir).original_first_thunk
            } else {
                (*idir).first_thunk
            };
            
            let mut thunk_in: *const ImageThunkData = pe.ref_at(thunk_in).unwrap();
            let mut thunk_out = (h.image_base + (*idir).first_thunk.get() as u64) as *mut u64;
            //println!("{:p} {:p}", thunk_in, thunk_out);
            
            loop {
                let thing = (*thunk_in).thing;
                if thing == 0 { break; }

                if (thing & 0x8000000000000000) != 0 {
                    // skip ordinal imports
                    *thunk_out = ordinal_import_stub as u64;
                } else {
                    let iibn = RVA::new(thing as u32 + 2);
                    let name = pe.ref_cstr_at(iibn).unwrap().as_os_str();

                    *thunk_out = name.to_str().and_then(|x| WINAPI.get(x)).cloned().unwrap_or(unknown_import_stub as u64);
                }
                
                thunk_in = thunk_in.offset(1);
                thunk_out = thunk_out.offset(1);
            }
            
            
            idir = idir.offset(1);
        }
    }
}

fn load_pe(data: &mut [u8]) -> (u64, ExportTable) {
    let pdata = data.as_ptr();
    let pe = Pe::new(data).unwrap();

    match pe.get_optional_header() {
        PeOptionalHeader::Pe32(_) => unimplemented!(),
        PeOptionalHeader::Pe32Plus(h) => {
            //println!("image base: {:p}", h.image_base as *mut ());

            map(&pe, h, pdata);
            link(&pe, h);

            let entry = h.image_base + h.address_of_entry_point.get() as u64;
            (entry, get_direct_exports(&pe, h).unwrap_or(HashMap::new()))
        }
    }
}

pub type DllEntryPoint = extern "win64" fn(*mut (), u32, *mut ());
pub type FuckingShit = extern "win64" fn(*mut c_void, *const u8, usize, *mut *mut u8, *mut usize) -> usize;

lazy_static! {
    static ref COREFP: Mutex<Option<ExportTable>> = Mutex::new(None);
}

fn main() {
    let mut data = Vec::new();

    println!("Loading CoreFP.dll");
    File::open("/tmp/iTunes/CoreFP.dll").unwrap().read_to_end(&mut data).unwrap();
    let (fp_entry, fp_exports) = load_pe(&mut data);
    let fp_entry: DllEntryPoint = unsafe { mem::transmute(fp_entry) };
    data.clear();

    println!("Loading iTunes.exe");
    File::open("/tmp/iTunes/iTunes.exe").unwrap().read_to_end(&mut data).unwrap();
    let (_, _) = load_pe(&mut data);
    drop(data);

    fp_entry(ptr::null_mut(), 1, ptr::null_mut());
    
    println!("====================================");
    println!("====================================");
    println!("====================================");

    unsafe {
        // monkeypatch alloca stubs because fuck that shit
        ptr::write(0x07df5d890 as *mut u8, 0xc3);
        ptr::write(0x1416c7080 as *mut u8, 0xc3);
    }
    // get things ready
    *COREFP.lock().unwrap() = Some(fp_exports);

    let fuckingshit: FuckingShit = unsafe { mem::transmute(0x1400556c0u64) };
    let payload = b"lul";
    let mut ret_buf: *mut u8 = ptr::null_mut();
    let mut ret_len = 0;
    let ret = fuckingshit(1 as *mut c_void, payload.as_ptr(), payload.len(), &mut ret_buf, &mut ret_len);
    //let ret = fuckingshit(), ptr::null(), 0, ptr::null_mut(), ptr::null_mut());
    println!("{} {:p} {}", ret, ret_buf, ret_len);
}
